AWSTemplateFormatVersion: 2010-09-09
Outputs:
  personalizeStackPersonalizebucketS3:
    Description: >-
      S3 Bucket to upload and store user-interaction json file and preprocessed
      csv file
    Value: !Ref PersonalizeBucket
  personalizeStackPersonalizeBatchbucketS3:
    Description: >-
      Personalize Batch job update the result to this S3 bucket
    Value: !Ref PersonalizeBatchBucket
  APIEndpoint:
    Description: API Gateway endpoint for Recommendation
    Value: !Sub >-
      https://${ServerlessRestApi}.execute-api.${AWS::Region}.amazonaws.com/Prod
  CfDistributionDomainName:
    Description: 'Domain name for our cloudfront distribution'
    Value: !GetAtt CfDistribution.DomainName
  S3CopyCLIForLAB3:
    Description: Amazon S3 Bucket copy cli for LAB 3
    Value: !Sub >-
      aws s3 cp ~/environment/personalizeworkshop/demogoprime-click-source-data.parquet s3://${PersonalizeBucket}/demogoprime-click-source-data.parquet
  S3CopyCLIForLAB5:
    Description: Amazon S3 Bucket copy cli for LAB 5
    Value: !Sub >-
      aws s3 cp ~/environment/personalizeworkshop/demogoprime-click-stream-data.parquet s3://${PersonalizeBucket}/demogoprime-click-stream-data.parquet
  DeploytoCloudFront:
    Description: Deploy react application to S3 for static web hosting
    Value: !Sub >-
      aws s3 sync ~/environment/personalizeworkshop/build s3://${S3Bucket}

Description: demogoprime-personalize
# S3CopyCLIForLAB3:
#     Description: Amazon S3 Bucket copy cli
#     Value: !Sub >-
#           aws s3 cp ~/environment/personalizeworkshop/demogoprime-click-source-data.parquet s3://<personalize-stack-personalizebucket-xxxxxx>/demogoprime-click-source-data.parquet
# Description: demogoprime-personalize
Resources:

  S3Bucket:
    DeletionPolicy: 'Delete'
    Metadata:
      Comment: 'Bucket to store some data'
    Properties:
      AccessControl: 'Private'
      BucketName: !Sub 'cf-simple-s3-origin-${AWS::StackName}-${AWS::AccountId}'
    Type: 'AWS::S3::Bucket'

  S3BucketPolicy:
    Metadata:
      Comment: 'Bucket policy to allow cloudfront to access the data'
    Properties:
      Bucket: !Ref S3Bucket
      PolicyDocument:
        Statement:
          - Action:
              - 's3:GetObject'
            Effect: 'Allow'
            Principal:
              CanonicalUser: !GetAtt CfOriginAccessIdentity.S3CanonicalUserId
            Resource:
              - !Sub 'arn:aws:s3:::${S3Bucket}/*'
    Type: 'AWS::S3::BucketPolicy'

  CfDistribution:
    Metadata:
      Comment: 'A simple CloudFront distribution with an S3 origin'
    Properties:
      DistributionConfig:
        Comment: 'A simple distribution with an S3 origin'
        DefaultCacheBehavior:
          AllowedMethods:
            - 'HEAD'
            - 'DELETE'
            - 'POST'
            - 'GET'
            - 'OPTIONS'
            - 'PUT'
            - 'PATCH'
          CachedMethods:
            - 'HEAD'
            - 'GET'
          Compress: false
          DefaultTTL: 86400
          ForwardedValues:
            Cookies:
              Forward: 'none'
            Headers:
              - 'Origin'
            QueryString: false
          MaxTTL: 31536000
          MinTTL: 86400
          TargetOriginId: !Sub 's3-origin-${S3Bucket}'
          ViewerProtocolPolicy: 'redirect-to-https'
        DefaultRootObject: 'index.html'
        Enabled: true
        HttpVersion: 'http1.1'
        IPV6Enabled: false
        Origins:
          - DomainName: !GetAtt S3Bucket.DomainName
            Id: !Sub 's3-origin-${S3Bucket}'
            OriginPath: ''
            S3OriginConfig:
              OriginAccessIdentity: !Sub 'origin-access-identity/cloudfront/${CfOriginAccessIdentity}'
        PriceClass: 'PriceClass_All'
    Type: 'AWS::CloudFront::Distribution'

  CfOriginAccessIdentity:
    Metadata:
      Comment: 'Access S3 bucket content only through CloudFront'
    Properties:
      CloudFrontOriginAccessIdentityConfig:
        Comment: 'Access S3 bucket content only through CloudFront'
    Type: 'AWS::CloudFront::CloudFrontOriginAccessIdentity'



  KinesisProcessingFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        ZipFile: |
        
            import os
            import json
            import boto3
            import base64

            personalize_events = boto3.client(service_name='personalize-events')
            trackingId = os.environ['TRACKING_ID']

            def lambda_handler(event, context):
                try:
                    for record in event['Records']:
                        # Kinesis data is base64 encoded so decode here
                        payload = base64.b64decode(record['kinesis']['data']).decode('utf-8')

                        # push_event_to_Personalize(json.loads(payload))
                        body = json.loads(payload)
                        response = personalize_events.put_events(
                            trackingId = trackingId,
                            userId = body['USER_ID'],
                            sessionId = body['USER_ID'],
                            eventList = [{
                                'eventType': body['EVENT_TYPE'].upper(),
                                'sentAt': str(int(body['TIMESTAMP'])/1000),
                                'itemId': body['ITEM_ID']
                            }]
                        )
                        
                    return 'Successfully processed {} records.'.format(len(event['Records']))
                except Exception as e:
                    raise e
                


      FunctionName: kinesisProcessingFunction
      Description: >-
        Real time API from personalize
      Tags:
        - Value: SAM
          Key: 'lambda:createdBy'
      Environment:
        Variables:
          TRACKING_ID: copynewtrackingIDFromEventTrack
      Handler: index.lambda_handler
      Role: !GetAtt 
        - KinesisProcessingFunctionRole
        - Arn
      Runtime: python3.6

  
  KinesisProcessingFunctionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Action:
              - 'sts:AssumeRole'
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
                - apigateway.amazonaws.com
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
        - PolicyName: KinesisProcessingFunctionRolePolicy0
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Action:
                  - 'logs:CreateLogGroup'
                Resource: '*'
                Effect: Allow
              - Action:
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: 'arn:aws:logs:*:*:log-group:/aws/lambda-insights:*'
                Effect: Allow
        - PolicyName: KinesisProcessingFunctionRolePolicy1
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Action:
                  - 'kinesis:Get*'
                  - 'kinesis:List*'
                  - 'kinesis:Describe*'
                  - 'kinesis:put*'
                Resource: '*'
                Effect: Allow
        - PolicyName: KinesisProcessingFunctionRolePolicy2
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Action:
                  - 'personalize:*'
                Resource: '*'
                Effect: Allow
        - PolicyName: KinesisProcessingFunctionRolePolicy3
          PolicyDocument:
            Statement:
              - Action:
                  - 'dynamodb:GetItem'
                  - 'dynamodb:DeleteItem'
                  - 'dynamodb:PutItem'
                  - 'dynamodb:Scan'
                  - 'dynamodb:Query'
                  - 'dynamodb:UpdateItem'
                  - 'dynamodb:BatchWriteItem'
                  - 'dynamodb:BatchGetItem'
                  - 'dynamodb:DescribeTable'
                  - 'dynamodb:ConditionCheckItem'
                Resource:
                  - !Sub 
                    - >-
                      arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tableName}
                    - tableName: !Ref MovieTable
                  - !Sub 
                    - >-
                      arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tableName}/index/*
                    - tableName: !Ref MovieTable
                Effect: Allow
        - PolicyName: KinesisProcessingFunctionRolePolicy4
          PolicyDocument:
            Statement:
              - Action:
                  - 's3:GetObject'
                  - 's3:GetObjectAcl'
                  - 's3:GetObjectVersion'
                  - 's3:PutObject'
                  - 's3:PutObjectAcl'
                  - 's3:DeleteObject'
                  - 's3:DeleteObjectTagging'
                  - 's3:DeleteObjectVersionTagging'
                  - 's3:GetObjectTagging'
                  - 's3:GetObjectVersionTagging'
                  - 's3:PutObjectTagging'
                  - 's3:PutObjectVersionTagging'
                Resource:
                  - !Sub 
                    - 'arn:${AWS::Partition}:s3:::${bucketName}/*'
                    - bucketName: !Ref PersonalizeBucket
                Effect: Allow
              - Action:
                  - 's3:ListBucket'
                  - 's3:GetBucketLocation'
                  - 's3:GetLifecycleConfiguration'
                  - 's3:PutLifecycleConfiguration'
                Resource:
                  - !Sub 
                    - 'arn:${AWS::Partition}:s3:::${bucketName}'
                    - bucketName: !Ref PersonalizeBucket
                Effect: Allow





  KinesisStreamFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        ZipFile: |
        
            import json
            import logging
            import boto3
            from botocore.exceptions import ClientError

            logger = logging.getLogger(__name__)

            kinesis = boto3.client("kinesis")

            def put_record(name, data, partition_key):
                try:
                    response = kinesis.put_record(
                        StreamName=name,
                        Data=json.dumps(data),
                        PartitionKey=partition_key)
                except ClientError:
                    logger.exception("Couldn't put record in stream %s.", name)
                    raise
                else:
                    return response

            def lambda_handler(event, context):
                print(event)
                
                kinesis_stream = 'demogoprime-kinesis-stream-prd'
                partition_key = event["PartitionKey"]
                data = event["Data"]
                
                response = put_record(kinesis_stream, data, partition_key)
                
                # TODO implement
                return {
                    'statusCode': 200,
                    'headers': {
                        "Content-Type" : "application/json",
                        "Access-Control-Allow-Origin" : "*",
                        "Allow" : "GET, OPTIONS, POST",
                        "Access-Control-Allow-Methods" : "GET, OPTIONS, POST",
                        "Access-Control-Allow-Headers" : "*"
                    },
                    'body': json.dumps(response)
                }
                


      FunctionName: kinesisPutFunction
      Description: >-
        Real time API from personalize
      Tags:
        - Value: SAM
          Key: 'lambda:createdBy'
      Environment:
        Variables:
          TRACKING_ID: fa718ea1-e638-40b1-ae13-58fd17f94eb9
      Handler: index.lambda_handler
      Role: !GetAtt 
        - KinesisStreamFunctionRole
        - Arn
      Runtime: python3.6

  
  KinesisStreamFunctionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Action:
              - 'sts:AssumeRole'
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
                - apigateway.amazonaws.com
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
        - PolicyName: KinesisStreamFunctionRolePolicy0
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Action:
                  - 'logs:CreateLogGroup'
                Resource: '*'
                Effect: Allow
              - Action:
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: 'arn:aws:logs:*:*:log-group:/aws/lambda-insights:*'
                Effect: Allow
        - PolicyName: KinesisStreamFunctionRolePolicy1
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Action:
                  - 'kinesis:Get*'
                  - 'kinesis:List*'
                  - 'kinesis:Describe*'
                  - 'kinesis:put*'
                Resource: '*'
                Effect: Allow
        - PolicyName: RealtimeRecommendationFunctionRolePolicy3
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Action:
                  - 'personalize:*'
                Resource: '*'
                Effect: Allow
        - PolicyName: RealtimeRecommendationFunctionRolePolicy4
          PolicyDocument:
            Statement:
              - Action:
                  - 'dynamodb:GetItem'
                  - 'dynamodb:DeleteItem'
                  - 'dynamodb:PutItem'
                  - 'dynamodb:Scan'
                  - 'dynamodb:Query'
                  - 'dynamodb:UpdateItem'
                  - 'dynamodb:BatchWriteItem'
                  - 'dynamodb:BatchGetItem'
                  - 'dynamodb:DescribeTable'
                  - 'dynamodb:ConditionCheckItem'
                Resource:
                  - !Sub 
                    - >-
                      arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tableName}
                    - tableName: !Ref MovieTable
                  - !Sub 
                    - >-
                      arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tableName}/index/*
                    - tableName: !Ref MovieTable
                Effect: Allow
        - PolicyName: RealtimeRecommendationFunctionRolePolicy5
          PolicyDocument:
            Statement:
              - Action:
                  - 's3:GetObject'
                  - 's3:GetObjectAcl'
                  - 's3:GetObjectVersion'
                  - 's3:PutObject'
                  - 's3:PutObjectAcl'
                  - 's3:DeleteObject'
                  - 's3:DeleteObjectTagging'
                  - 's3:DeleteObjectVersionTagging'
                  - 's3:GetObjectTagging'
                  - 's3:GetObjectVersionTagging'
                  - 's3:PutObjectTagging'
                  - 's3:PutObjectVersionTagging'
                Resource:
                  - !Sub 
                    - 'arn:${AWS::Partition}:s3:::${bucketName}/*'
                    - bucketName: !Ref PersonalizeBucket
                Effect: Allow
              - Action:
                  - 's3:ListBucket'
                  - 's3:GetBucketLocation'
                  - 's3:GetLifecycleConfiguration'
                  - 's3:PutLifecycleConfiguration'
                Resource:
                  - !Sub 
                    - 'arn:${AWS::Partition}:s3:::${bucketName}'
                    - bucketName: !Ref PersonalizeBucket
                Effect: Allow
      Tags:
        - Value: SAM
          Key: 'lambda:createdBy'


  RealtimeRecommendationFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        ZipFile: |
        
            import os
            import json
            import boto3
            from operator import itemgetter

            campaignArn = os.environ['CAMPAIGN_ARN']
            personalizeRt = boto3.client('personalize-runtime')
            dynamodb = boto3.resource('dynamodb')

            movie_table = dynamodb.Table('Movie')

            def get_personalize_recommendations(userId):
                response = personalizeRt.get_recommendations(
                    campaignArn = campaignArn,
                    userId = userId,
                    numResults = 3
                )
                
                return response
                
            def lambda_handler(event, context):
                userId = event['pathParameters']['id']
                response = get_personalize_recommendations(userId)
                movie_list = response['itemList']
                
                item_ids = []
                
                for movie in movie_list:
                    item_ids.append(movie['itemId'])
                    
                batch_keys = {
                    movie_table.name: {
                        'Keys': [{'id': movie['itemId']} for movie in movie_list],
                        'ProjectionExpression': 'id, #name, category, imageUrl',
                        'ExpressionAttributeNames': {'#name': 'name'}
                    }
                }
                
                response = dynamodb.batch_get_item(RequestItems=batch_keys)
                recommendations = response['Responses']['Movie']
                
                for recommendation in recommendations:
                    for movie in movie_list:
                        if recommendation['id'] == movie['itemId']:
                            recommendation['score'] = movie['score']
                            
                recommendations = sorted(recommendations, key=itemgetter('score'), reverse=True)
                
                response = {
                    'movies': recommendations
                }
                
                return {
                    'statusCode': 200,        
                    'headers': {
                        'Access-Control-Allow-Headers': 'Content-Type',
                        'Access-Control-Allow-Origin': '*',
                        'Access-Control-Allow-Methods': 'OPTIONS,POST,GET'
                    },
                    'body': json.dumps(response)
                }

      FunctionName: personalizeProcessingFunction
      Description: >-
        Real time API from personalize
      Tags:
        - Value: SAM
          Key: 'lambda:createdBy'
      Environment:
        Variables:
          CAMPAIGN_ARN: copyPasteCampaignARNHere
      Handler: index.lambda_handler
      Role: !GetAtt 
        - RealtimeRecommendationFunctionRole
        - Arn
      Runtime: python3.6
  cloud9Environment:
    Type: 'AWS::Cloud9::EnvironmentEC2'
    Properties:
      Repositories:
        - RepositoryUrl: 'https://github.com/aws-samples/amazon-personalize-with-glue-databrew-front'
          PathComponent: personalizeworkshop
      Description: Use this to work with Frontend application
      InstanceType: t2.micro
      Name: personalizeworkshop
  putItemFunctionApiPermissionProd:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      Principal: apigateway.amazonaws.com
      FunctionName: !Ref putItemFunction
      SourceArn: !Sub 
        - >-
          arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${__ApiId__}/${__Stage__}/POST/movie
        - __Stage__: '*'
          __ApiId__: !Ref ServerlessRestApi
  getAllUserFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        ZipFile: |
            
            const tableName = process.env.SAMPLE_TABLE;

            // Create a DocumentClient that represents the query to add an item
            const dynamodb = require('aws-sdk/clients/dynamodb');
            const docClient = new dynamodb.DocumentClient();

            /**
            * A simple example includes a HTTP get method to get all items from a DynamoDB table.
            */
            exports.getAllUsersHandler = async (event) => {
                if (event.httpMethod !== 'GET') {
                    throw new Error(`getAllItems only accept GET method, you tried: ${event.httpMethod}`);
                }
                // All log statements are written to CloudWatch
                console.info('received:', event);

                // get all items from the table (only first 1MB data, you can use `LastEvaluatedKey` to get the rest of data)
                // https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html#scan-property
                // https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Scan.html
                var params = {
                    TableName : tableName
                };
                const data = await docClient.scan(params).promise();
                const items = data.Items;

                const response = {
                    statusCode: 200,
                    headers: {
                        'Access-Control-Allow-Headers': 'Content-Type',
                        'Access-Control-Allow-Origin': '*',
                        'Access-Control-Allow-Methods': 'OPTIONS,POST,GET'
                    },
                    body: JSON.stringify(items)
                };

                // All log statements are written to CloudWatch
                console.info(`response from: ${event.path} statusCode: ${response.statusCode} body: ${response.body}`);
                return response;
            }


      FunctionName: getAllUserFunction  
      Description: >-
        A simple example includes a HTTP get method to get all users from a User
        table.
      Tags:
        - Value: SAM
          Key: 'lambda:createdBy'
      MemorySize: 128
      Environment:
        Variables:
          SAMPLE_TABLE: !Ref UserTable
      Handler: index.getAllUsersHandler
      Role: !GetAtt 
        - getAllUserFunctionRole
        - Arn
      Timeout: 100
      Runtime: nodejs12.x
  getAllItemsFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        ZipFile: |
            // Create clients and set shared const values outside of the handler.

            // Get the DynamoDB table name from environment variables
            const tableName = process.env.SAMPLE_TABLE;

            // Create a DocumentClient that represents the query to add an item
            const dynamodb = require('aws-sdk/clients/dynamodb');
            const docClient = new dynamodb.DocumentClient();

            /**
            * A simple example includes a HTTP get method to get all items from a DynamoDB table.
            */
            exports.getAllItemsHandler = async (event) => {
                if (event.httpMethod !== 'GET') {
                    throw new Error(`getAllItems only accept GET method, you tried: ${event.httpMethod}`);
                }
                // All log statements are written to CloudWatch
                console.info('received:', event);

                // get all items from the table (only first 1MB data, you can use `LastEvaluatedKey` to get the rest of data)
                // https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html#scan-property
                // https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Scan.html
                var params = {
                    TableName : tableName
                };
                const data = await docClient.scan(params).promise();
                const items = data.Items;

                const response = {
                    statusCode: 200,
                    headers: {
                        'Access-Control-Allow-Headers': 'Content-Type',
                        'Access-Control-Allow-Origin': '*',
                        'Access-Control-Allow-Methods': 'OPTIONS,POST,GET'
                    },
                    body: JSON.stringify(items)
                };

                // All log statements are written to CloudWatch
                console.info(`response from: ${event.path} statusCode: ${response.statusCode} body: ${response.body}`);
                return response;
            }

        
      FunctionName: getAllMovieFunction  
      Description: >-
        A simple example includes a HTTP get method to get all items from a
        DynamoDB table.
      Tags:
        - Value: SAM
          Key: 'lambda:createdBy'
      MemorySize: 128
      Environment:
        Variables:
          SAMPLE_TABLE: !Ref MovieTable
      Handler: index.getAllItemsHandler
      Role: !GetAtt 
        - getAllItemsFunctionRole
        - Arn
      Timeout: 100
      Runtime: nodejs12.x
  getAllItemsFunctionApiPermissionProd:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      Principal: apigateway.amazonaws.com
      FunctionName: !Ref getAllItemsFunction
      SourceArn: !Sub 
        - >-
          arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${__ApiId__}/${__Stage__}/GET/movie
        - __Stage__: '*'
          __ApiId__: !Ref ServerlessRestApi
  getAllItemsFunctionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Action:
              - 'sts:AssumeRole'
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
        - PolicyName: getAllItemsFunctionRolePolicy0
          PolicyDocument:
            Statement:
              - Action:
                  - 'dynamodb:GetItem'
                  - 'dynamodb:DeleteItem'
                  - 'dynamodb:PutItem'
                  - 'dynamodb:Scan'
                  - 'dynamodb:Query'
                  - 'dynamodb:UpdateItem'
                  - 'dynamodb:BatchWriteItem'
                  - 'dynamodb:BatchGetItem'
                  - 'dynamodb:DescribeTable'
                  - 'dynamodb:ConditionCheckItem'
                Resource:
                  - !Sub 
                    - >-
                      arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tableName}
                    - tableName: !Ref MovieTable
                  - !Sub 
                    - >-
                      arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tableName}/index/*
                    - tableName: !Ref MovieTable
                Effect: Allow
      Tags:
        - Value: SAM
          Key: 'lambda:createdBy'
  BatchRecommendationFunctionApiPermissionProd:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      Principal: apigateway.amazonaws.com
      FunctionName: !Ref BatchRecommendationFunction
      SourceArn: !Sub 
        - >-
          arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${__ApiId__}/${__Stage__}/GET/recommendation/batch/*
        - __Stage__: '*'
          __ApiId__: !Ref ServerlessRestApi
  MovieTable:
    Type: 'AWS::DynamoDB::Table'
    Properties:
      ProvisionedThroughput:
        WriteCapacityUnits: 2
        ReadCapacityUnits: 2
      TableName: Movie
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
      KeySchema:
        - KeyType: HASH
          AttributeName: id


  BatchTable:
    Type: 'AWS::DynamoDB::Table'
    Properties:
      ProvisionedThroughput:
        WriteCapacityUnits: 2
        ReadCapacityUnits: 2
      TableName: personalize-batch
      AttributeDefinitions:
        - AttributeName: user-id
          AttributeType: N
      KeySchema:
        - KeyType: HASH
          AttributeName: user-id


  getByIdFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        ZipFile: |
        
            // Create clients and set shared const values outside of the handler.

            // Get the DynamoDB table name from environment variables
            const tableName = process.env.SAMPLE_TABLE;

            // Create a DocumentClient that represents the query to add an item
            const dynamodb = require('aws-sdk/clients/dynamodb');
            const docClient = new dynamodb.DocumentClient();

            /**
            * A simple example includes a HTTP get method to get one item by id from a DynamoDB table.
            */
            exports.getByIdHandler = async (event) => {
              if (event.httpMethod !== 'GET') {
                throw new Error(`getMethod only accept GET method, you tried: ${event.httpMethod}`);
              }
              // All log statements are written to CloudWatch
              console.info('received:', event);
            
              // Get id from pathParameters from APIGateway because of `/{id}` at template.yml
              const id = event.pathParameters.id;
            
              // Get the item from the table
              // https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html#get-property
              var params = {
                TableName : tableName,
                Key: { id: id },
              };
              const data = await docClient.get(params).promise();
              const item = data.Item;
            
              const response = {
                statusCode: 200,
                headers: {
                        'Access-Control-Allow-Headers': 'Content-Type',
                        'Access-Control-Allow-Origin': '*',
                        'Access-Control-Allow-Methods': 'OPTIONS,POST,GET'
                    },
                body: JSON.stringify(item)
              };
            
              // All log statements are written to CloudWatch
              console.info(`response from: ${event.path} statusCode: ${response.statusCode} body: ${response.body}`);
              return response;
            }

      FunctionName: getMovieByIdFunction
      Description: >-
        A simple example includes a HTTP get method to get one item by id from a
        DynamoDB table.
      Tags:
        - Value: SAM
          Key: 'lambda:createdBy'
      MemorySize: 128
      Environment:
        Variables:
          SAMPLE_TABLE: !Ref MovieTable
      Handler: index.getByIdHandler
      Role: !GetAtt 
        - getByIdFunctionRole
        - Arn
      Timeout: 100
      Runtime: nodejs12.x
  getAllUserFunctionApiPermissionProd:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      Principal: apigateway.amazonaws.com
      FunctionName: !Ref getAllUserFunction
      SourceArn: !Sub 
        - >-
          arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${__ApiId__}/${__Stage__}/GET/user
        - __Stage__: '*'
          __ApiId__: !Ref ServerlessRestApi
  ServerlessRestApiDeployment5e9547a85c:
    Type: 'AWS::ApiGateway::Deployment'
    Properties:
      RestApiId: !Ref ServerlessRestApi
      Description: 'RestApi deployment id: 5e9547a85c88b6432d801236b6963dad7c96d148'
      StageName: Stage
  BatchRecommendationFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        ZipFile: |
            
            import boto3,json
            dynamodb = boto3.resource('dynamodb')
            table = dynamodb.Table('personalize-batch')
            movie_table = dynamodb.Table('Movie')

            def lambda_handler(event, context):
                print(event)
                userId = event['pathParameters']['id']
                response = table.get_item(
                    Key={
                        'user-id' : int(userId)
                    }
                )

                #print(response['Item']['item-list'])
                movie_list = response['Item']['item-list']
                score_set = response['Item']['score-list']
                score_list = list(score_set)

                batch_keys = {
                    movie_table.name: {
                        'Keys': [{'id': movie} for movie in movie_list],
                        'ProjectionExpression': 'id, #name, category, imageUrl',
                        'ExpressionAttributeNames': {'#name': 'name'}
                    }
                }
                bat_response = dynamodb.batch_get_item(RequestItems=batch_keys)
                recommendations = bat_response['Responses']['Movie']


                for recommendation in recommendations:
                    i=0;
                    for movie in movie_list:
                        if recommendation['id'] == movie:
                            recommendation['score'] = score_list[i]
                        i = i+1

                response = {
                    'movies': recommendations
                }
                
                return {
                    'statusCode': 200,
                    'headers': {
                        'Access-Control-Allow-Headers': 'Content-Type',
                        'Access-Control-Allow-Origin': '*',
                        'Access-Control-Allow-Methods': 'OPTIONS,POST,GET'
                    },
                    'body': json.dumps(response)
                }

      FunctionName: batchRecommendationProcessingFunction 
      Description: >-
        Batch API from Personalize.
      Tags:
        - Value: SAM
          Key: 'lambda:createdBy'
      Environment:
        Variables:
          CAMPAIGN_ARN: copyPasteCampaignARNHere
      Handler: index.lambda_handler
      Role: !GetAtt 
        - BatchRecommendationFunctionRole
        - Arn
      Runtime: python3.6
  RealtimeRecommendationFunctionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Action:
              - 'sts:AssumeRole'
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
        - PolicyName: RealtimeRecommendationFunctionRolePolicy0
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Action:
                  - 'personalize:*'
                Resource: '*'
                Effect: Allow
        - PolicyName: RealtimeRecommendationFunctionRolePolicy1
          PolicyDocument:
            Statement:
              - Action:
                  - 'dynamodb:GetItem'
                  - 'dynamodb:DeleteItem'
                  - 'dynamodb:PutItem'
                  - 'dynamodb:Scan'
                  - 'dynamodb:Query'
                  - 'dynamodb:UpdateItem'
                  - 'dynamodb:BatchWriteItem'
                  - 'dynamodb:BatchGetItem'
                  - 'dynamodb:DescribeTable'
                  - 'dynamodb:ConditionCheckItem'
                Resource:
                  - !Sub 
                    - >-
                      arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tableName}
                    - tableName: !Ref MovieTable
                  - !Sub 
                    - >-
                      arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tableName}/index/*
                    - tableName: !Ref MovieTable
                Effect: Allow
        - PolicyName: RealtimeRecommendationFunctionRolePolicy2
          PolicyDocument:
            Statement:
              - Action:
                  - 's3:GetObject'
                  - 's3:GetObjectAcl'
                  - 's3:GetObjectVersion'
                  - 's3:PutObject'
                  - 's3:PutObjectAcl'
                  - 's3:DeleteObject'
                  - 's3:DeleteObjectTagging'
                  - 's3:DeleteObjectVersionTagging'
                  - 's3:GetObjectTagging'
                  - 's3:GetObjectVersionTagging'
                  - 's3:PutObjectTagging'
                  - 's3:PutObjectVersionTagging'
                Resource:
                  - !Sub 
                    - 'arn:${AWS::Partition}:s3:::${bucketName}/*'
                    - bucketName: !Ref PersonalizeBucket
                Effect: Allow
              - Action:
                  - 's3:ListBucket'
                  - 's3:GetBucketLocation'
                  - 's3:GetLifecycleConfiguration'
                  - 's3:PutLifecycleConfiguration'
                Resource:
                  - !Sub 
                    - 'arn:${AWS::Partition}:s3:::${bucketName}'
                    - bucketName: !Ref PersonalizeBucket
                Effect: Allow
      Tags:
        - Value: SAM
          Key: 'lambda:createdBy'
  putItemFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        ZipFile: |

            // Create clients and set shared const values outside of the handler.

            // Create a DocumentClient that represents the query to add an item
            const dynamodb = require('aws-sdk/clients/dynamodb');
            const docClient = new dynamodb.DocumentClient();

            // Get the DynamoDB table name from environment variables
            const tableName = process.env.SAMPLE_TABLE;

            /**
            * A simple example includes a HTTP post method to add one item to a DynamoDB table.
            */
            exports.putItemHandler = async (event) => {
                if (event.httpMethod !== 'POST') {
                    throw new Error(`postMethod only accepts POST method, you tried: ${event.httpMethod} method.`);
                }
                // All log statements are written to CloudWatch
                console.info('received:', event);

                // Get id and name from the body of the request
                const body = JSON.parse(event.body)
                const id = body.id;
                const name = body.name;

                // Creates a new item, or replaces an old item with a new item
                // https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html#put-property
                var params = {
                    TableName : tableName,
                    Item: { id : id, name: name }
                };

                const result = await docClient.put(params).promise();

                const response = {
                    statusCode: 200,
                    headers: {
                        'Access-Control-Allow-Headers': 'Content-Type',
                        'Access-Control-Allow-Origin': '*',
                        'Access-Control-Allow-Methods': 'OPTIONS,POST,GET'
                    },
                    body: JSON.stringify(body)
                };

                // All log statements are written to CloudWatch
                console.info(`response from: ${event.path} statusCode: ${response.statusCode} body: ${response.body}`);
                return response;
            }

      FunctionName: putMovieFunction
      Description: >-
        A simple example includes a HTTP post method to add one item to a
        DynamoDB table.
      Tags:
        - Value: SAM
          Key: 'lambda:createdBy'
      MemorySize: 128
      Environment:
        Variables:
          SAMPLE_TABLE: !Ref MovieTable
      Handler: index.putItemHandler
      Role: !GetAtt 
        - putItemFunctionRole
        - Arn
      Timeout: 100
      Runtime: nodejs12.x
  getByIdFunctionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Action:
              - 'sts:AssumeRole'
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
        - PolicyName: getByIdFunctionRolePolicy0
          PolicyDocument:
            Statement:
              - Action:
                  - 'dynamodb:GetItem'
                  - 'dynamodb:DeleteItem'
                  - 'dynamodb:PutItem'
                  - 'dynamodb:Scan'
                  - 'dynamodb:Query'
                  - 'dynamodb:UpdateItem'
                  - 'dynamodb:BatchWriteItem'
                  - 'dynamodb:BatchGetItem'
                  - 'dynamodb:DescribeTable'
                  - 'dynamodb:ConditionCheckItem'
                Resource:
                  - !Sub 
                    - >-
                      arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tableName}
                    - tableName: !Ref MovieTable
                  - !Sub 
                    - >-
                      arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tableName}/index/*
                    - tableName: !Ref MovieTable
                Effect: Allow
      Tags:
        - Value: SAM
          Key: 'lambda:createdBy'
  BatchRecommendationFunctionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Action:
              - 'sts:AssumeRole'
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
        - PolicyName: BatchRecommendationFunctionRolePolicy0
          PolicyDocument:
            Statement:
              - Action:
                  - 'dynamodb:GetItem'
                  - 'dynamodb:DeleteItem'
                  - 'dynamodb:PutItem'
                  - 'dynamodb:Scan'
                  - 'dynamodb:Query'
                  - 'dynamodb:UpdateItem'
                  - 'dynamodb:BatchWriteItem'
                  - 'dynamodb:BatchGetItem'
                  - 'dynamodb:DescribeTable'
                  - 'dynamodb:ConditionCheckItem'
                Resource:
                  - !Sub 
                    - >-
                      arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tableName}
                    - tableName: !Ref MovieTable
                  - !Sub 
                    - >-
                      arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tableName}/index/*
                    - tableName: !Ref MovieTable
                  - !Sub 
                    - >-
                      arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tableName}
                    - tableName: !Ref BatchTable
                  - !Sub 
                    - >-
                      arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tableName}/index/*
                    - tableName: !Ref BatchTable
                Effect: Allow
        - PolicyName: BatchRecommendationFunctionRolePolicy1
          PolicyDocument:
            Statement:
              - Action:
                  - 's3:GetObject'
                  - 's3:GetObjectAcl'
                  - 's3:GetObjectVersion'
                  - 's3:PutObject'
                  - 's3:PutObjectAcl'
                  - 's3:DeleteObject'
                  - 's3:DeleteObjectTagging'
                  - 's3:DeleteObjectVersionTagging'
                  - 's3:GetObjectTagging'
                  - 's3:GetObjectVersionTagging'
                  - 's3:PutObjectTagging'
                  - 's3:PutObjectVersionTagging'
                Resource:
                  - !Sub 
                    - 'arn:${AWS::Partition}:s3:::${bucketName}/*'
                    - bucketName: !Ref PersonalizeBucket
                  - !Sub 
                    - 'arn:${AWS::Partition}:s3:::${bucketName}/*'
                    - bucketName: !Ref PersonalizeBatchBucket
                Effect: Allow
              - Action:
                  - 's3:ListBucket'
                  - 's3:GetBucketLocation'
                  - 's3:GetLifecycleConfiguration'
                  - 's3:PutLifecycleConfiguration'
                Resource:
                  - !Sub 
                    - 'arn:${AWS::Partition}:s3:::${bucketName}'
                    - bucketName: !Ref PersonalizeBucket
                  - !Sub 
                    - 'arn:${AWS::Partition}:s3:::${bucketName}'
                    - bucketName: !Ref PersonalizeBatchBucket
                Effect: Allow
        - PolicyName: BatchRecommendationFunctionRolePolicy2
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Action:
                  - 'personalize:*'
                Resource: '*'
                Effect: Allow
      Tags:
        - Value: SAM
          Key: 'lambda:createdBy'
  UserTable:
    Type: 'AWS::DynamoDB::Table'
    Properties:
      ProvisionedThroughput:
        WriteCapacityUnits: 2
        ReadCapacityUnits: 2
      TableName: User
      AttributeDefinitions:
        - AttributeName: userId
          AttributeType: S
      KeySchema:
        - KeyType: HASH
          AttributeName: userId

  ServerlessRestApi:
    Type: 'AWS::ApiGateway::RestApi'
    Properties:
      Body:
        info:
          version: '1.0'
          title: !Ref 'AWS::StackName'
        paths:
          '/movie/{id}':
            get:
              x-amazon-apigateway-integration:
                httpMethod: POST
                type: aws_proxy
                uri: !Sub >-
                  arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${getByIdFunction.Arn}/invocations
              responses: {}
          /movie:
            post:
              x-amazon-apigateway-integration:
                httpMethod: POST
                type: aws_proxy
                uri: !Sub >-
                  arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${putItemFunction.Arn}/invocations
              responses: {}
            get:
              x-amazon-apigateway-integration:
                httpMethod: POST
                type: aws_proxy
                uri: !Sub >-
                  arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${getAllItemsFunction.Arn}/invocations
              responses: {}
          '/recommendation/{id}':
            get:
              x-amazon-apigateway-integration:
                httpMethod: POST
                type: aws_proxy
                uri: !Sub >-
                  arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${RealtimeRecommendationFunction.Arn}/invocations
              responses: {}
          '/recommendation/batch/{id}':
            get:
              x-amazon-apigateway-integration:
                httpMethod: POST
                type: aws_proxy
                uri: !Sub >-
                  arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${BatchRecommendationFunction.Arn}/invocations
              responses: {}
          /user:
            get:
              x-amazon-apigateway-integration:
                httpMethod: POST
                type: aws_proxy
                uri: !Sub >-
                  arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${getAllUserFunction.Arn}/invocations
              responses: {}
          '/stream/demogoprime-kinesis-stream-prd/record':
            post:
              x-amazon-apigateway-integration:
                httpMethod: POST
                type: aws
                uri: !Sub >-
                  arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${KinesisStreamFunction.Arn}/invocations
              responses: {}
            
              
        swagger: '2.0'
      # Parameters:
      #           endpointConfigurationTypes: REGIONAL
  
  ModelAPI:
    Type: 'AWS::ApiGateway::Model'
    Properties:
      RestApiId: !Ref ServerlessRestApi
      ContentType: application/json
      Description: Schema for kinesis put
      Name: Empty
      Schema:
        $schema: 'http://json-schema.org/draft-04/schema#'
        title: Empty Schema
        type: object


  putItemFunctionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Action:
              - 'sts:AssumeRole'
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
        - PolicyName: putItemFunctionRolePolicy0
          PolicyDocument:
            Statement:
              - Action:
                  - 'dynamodb:GetItem'
                  - 'dynamodb:DeleteItem'
                  - 'dynamodb:PutItem'
                  - 'dynamodb:Scan'
                  - 'dynamodb:Query'
                  - 'dynamodb:UpdateItem'
                  - 'dynamodb:BatchWriteItem'
                  - 'dynamodb:BatchGetItem'
                  - 'dynamodb:DescribeTable'
                  - 'dynamodb:ConditionCheckItem'
                Resource:
                  - !Sub 
                    - >-
                      arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tableName}
                    - tableName: !Ref MovieTable
                  - !Sub 
                    - >-
                      arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tableName}/index/*
                    - tableName: !Ref MovieTable
                Effect: Allow
      Tags:
        - Value: SAM
          Key: 'lambda:createdBy'
  ServerlessRestApiProdStage:
    Type: 'AWS::ApiGateway::Stage'
    Properties:
      DeploymentId: !Ref ServerlessRestApiDeployment5e9547a85c
      RestApiId: !Ref ServerlessRestApi
      StageName: Prod
  getAllUserFunctionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Action:
              - 'sts:AssumeRole'
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
        - PolicyName: getAllUserFunctionRolePolicy0
          PolicyDocument:
            Statement:
              - Action:
                  - 'dynamodb:GetItem'
                  - 'dynamodb:DeleteItem'
                  - 'dynamodb:PutItem'
                  - 'dynamodb:Scan'
                  - 'dynamodb:Query'
                  - 'dynamodb:UpdateItem'
                  - 'dynamodb:BatchWriteItem'
                  - 'dynamodb:BatchGetItem'
                  - 'dynamodb:DescribeTable'
                  - 'dynamodb:ConditionCheckItem'
                Resource:
                  - !Sub 
                    - >-
                      arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tableName}
                    - tableName: !Ref UserTable
                  - !Sub 
                    - >-
                      arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tableName}/index/*
                    - tableName: !Ref UserTable
                Effect: Allow
      Tags:
        - Value: SAM
          Key: 'lambda:createdBy'
  
  PersonalizeBucket:
    Type: 'AWS::S3::Bucket'

  PersonalizeBatchBucket:
    Type: 'AWS::S3::Bucket'
    Properties:
      BucketName: !Sub personalize-stack-personalize-batchbucket-${AWS::AccountId}

  
  KinesisStream: 
    Type: AWS::Kinesis::Stream 
    Properties: 
        Name: demogoprime-kinesis-stream-prd 
        RetentionPeriodHours: 24 
        ShardCount: 1  


  
  getByIdFunctionApiPermissionProd:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      Principal: apigateway.amazonaws.com
      FunctionName: !Ref getByIdFunction
      SourceArn: !Sub 
        - >-
          arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${__ApiId__}/${__Stage__}/GET/movie/*
        - __Stage__: '*'
          __ApiId__: !Ref ServerlessRestApi

  RealtimeRecommendationFunctionApiPermissionProd:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      Principal: apigateway.amazonaws.com
      FunctionName: !Ref RealtimeRecommendationFunction
      SourceArn: !Sub 
        - >-
          arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${__ApiId__}/${__Stage__}/GET/recommendation/*
        - __Stage__: '*'
          __ApiId__: !Ref ServerlessRestApi
  
  EvenTrackerFunctionApiPermissionProd:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      Principal: apigateway.amazonaws.com
      FunctionName: !Ref KinesisStreamFunction
      SourceArn: !Sub 
        - >-
          arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${__ApiId__}/${__Stage__}/POST/stream/*
        - __Stage__: '*'
          __ApiId__: !Ref ServerlessRestApi
 
 
